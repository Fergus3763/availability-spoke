<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Admin — Availability & Blackouts</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/modern-normalize/modern-normalize.min.css">
  <style>
    body{font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Arial;padding:24px}
    .card{border:1px solid #e5e7eb;border-radius:16px;padding:16px;margin-bottom:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
    .row{display:flex;gap:8px;align-items:center;margin:8px 0;flex-wrap:wrap}
    input,select,button{padding:8px 10px;border-radius:10px;border:1px solid #d1d5db}
    table{width:100%;border-collapse:collapse}
    th,td{text-align:left;padding:8px;border-bottom:1px solid #eee}
    .muted{color:#6b7280;font-size:12px}
    .pill{background:#eef2ff;color:#3730a3;padding:2px 8px;border-radius:999px;font-size:12px}
  </style>
  <!-- React & Luxon from CDNs -->
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/luxon@3/build/global/luxon.min.js"></script>
</head>
<body>
  <div id="app"></div>

  <!-- Inline core (no imports) -->
  <script>
  (function(){
    const { DateTime, Interval } = luxon;
    const state = window.state = {
      timezone: "Europe/Dublin",
      calendars: { "Room-A": [], "Room-B": [] },
      roomConfig: { "Room-A": { preBufferMins: 15, postBufferMins: 15 }, "Room-B": { preBufferMins: 0, postBufferMins: 0 } },
      pricing: { earliestStart:"07:00", latestEnd:"22:00", roundingStep:15, halfDayHrs:4, dayHrs:8, oohPct:0.2 },
      openingHours: { MO:[{start:"07:00",end:"22:00"}], TU:[{start:"07:00",end:"22:00"}], WE:[{start:"07:00",end:"22:00"}], TH:[{start:"07:00",end:"22:00"}], FR:[{start:"07:00",end:"22:00"}], SA:[{start:"08:00",end:"20:00"}], SU:[] },
      defaults: { preBufferMins:0, postBufferMins:0, roundingStepMins:15, minLeadTimeMins:0, maxLeadTimeDays:365 }
    };
    const uid = () => Math.random().toString(36).slice(2,10);
    const parseISO = iso => DateTime.fromISO(iso, { setZone: true });
    const weekdayToken = dt => ["SU","MO","TU","WE","TH","FR","SA"][dt.weekday % 7];
    const isOnStep = (dt, step) => ((dt.minute + dt.hour*60) % step)===0 && dt.second===0 && dt.millisecond===0;
    const eu = iso => parseISO(iso).toFormat("HH:mm dd/MM/yyyy");
    const getRoomDefaults = roomId => state.roomConfig[roomId] || state.defaults;
    const applyBuffers = (ev, roomId) => {
      const cfg = getRoomDefaults(roomId);
      const pre = ev.preBufferMins ?? cfg.preBufferMins ?? 0;
      const post = ev.postBufferMins ?? cfg.postBufferMins ?? 0;
      return { start: parseISO(ev.startsAt).minus({minutes: pre}), end: parseISO(ev.endsAt).plus({minutes: post}) };
    };
    const intervalsOverlap = (aStart,aEnd,bStart,bEnd) => aStart < bEnd && bStart < aEnd;
    const checkOverlap = (roomId, candidate) => {
      const cal = state.calendars[roomId] || [];
      const { start: cStart, end: cEnd } = applyBuffers(candidate, roomId);
      for (const ev of cal) {
        if (ev.status === "cancelled") continue;
        const { start, end } = applyBuffers(ev, roomId);
        if (intervalsOverlap(cStart, cEnd, start, end)) {
          return { ok:false, reason:`Conflicts with ${ev.type} (${ev.title||ev.id})`, conflictingEvent: ev };
        }
      }
      return { ok:true };
    };
    const detectOOH = (ev) => {
      const start = parseISO(ev.startsAt), end = parseISO(ev.endsAt);
      let cursor = start;
      while (cursor < end){
        const segEnd = DateTime.min(cursor.endOf("day"), end);
        const ranges = state.openingHours[weekdayToken(cursor)] || [];
        const openIntervals = ranges.map(r => {
          const [sh, sm] = r.start.split(":").map(Number);
          const [eh, em] = r.end.split(":").map(Number);
          return Interval.fromDateTimes(
            cursor.set({hour:sh, minute:sm, second:0, millisecond:0}),
            cursor.set({hour:eh, minute:em, second:0, millisecond:0})
          );
        });
        const seg = Interval.fromDateTimes(cursor, segEnd);
        const covered = openIntervals.some(iv => iv.overlaps(seg) || iv.engulfs(seg));
        if (!covered) return true;
        cursor = segEnd;
      }
      return false;
    };
    const isAvailable = (roomId, fromISO, toISO) => {
      const step = state.pricing.roundingStep ?? state.defaults.roundingStepMins;
      const s = parseISO(fromISO), e = parseISO(toISO);
      if (!isOnStep(s, step) || !isOnStep(e, step)) return { available:false, reason:`Times must align to ${step}-minute steps` };
      const probe = { id:"_probe_", roomId, type:"BOOKING", status:"provisional", startsAt:fromISO, endsAt:toISO, createdBy:"system", createdAt: DateTime.now().toISO() };
      const overlap = checkOverlap(roomId, probe);
      if (!overlap.ok) return { available:false, reason: overlap.reason, conflictingEvent: overlap.conflictingEvent };
      return { available:true };
    };
    const addBlackout = (roomId, startsAtISO, endsAtISO, title="Blackout") => {
      const ev = { id:uid(), roomId, type:"BLACKOUT", status:"confirmed", startsAt:startsAtISO, endsAt:endsAtISO, title, createdBy:"admin", createdAt: DateTime.now().toISO() };
      const overlap = checkOverlap(roomId, ev);
      if (!overlap.ok) return { ok:false, reason: overlap.reason, conflictingEvent: overlap.conflictingEvent };
      (state.calendars[roomId] = state.calendars[roomId] || []).push(ev);
      return { ok:true, event: ev };
    };
    const addTempBlackout = (roomId, startsAtISO, amount, unit, title="Temp Block") => {
      const dur = {};
      if (unit === "hours") dur.hours = amount;
      else if (unit === "days") dur.days = amount;
      else if (unit === "weeks") dur.weeks = amount;
      else return { ok:false, reason:"Invalid unit (hours|days|weeks)" };
      const endsAtISO = parseISO(startsAtISO).plus(dur).toISO();
      const ev = { id:uid(), roomId, type:"TEMP_BLACKOUT", status:"confirmed", startsAt:startsAtISO, endsAt:endsAtISO, title, createdBy:"admin", createdAt: DateTime.now().toISO() };
      const overlap = checkOverlap(roomId, ev);
      if (!overlap.ok) return { ok:false, reason: overlap.reason, conflictingEvent: overlap.conflictingEvent };
      (state.calendars[roomId] = state.calendars[roomId] || []).push(ev);
      return { ok:true, event: ev };
    };
    const removeEvent = (roomId, id) => {
      const arr = state.calendars[roomId] || [];
      const idx = arr.findIndex(e => e.id === id);
      if (idx === -1) return { ok:false, reason:"Not found" };
      arr.splice(idx,1);
      return { ok:true };
    };
    const seedExamples = () => {
      const s = DateTime.fromISO("2025-11-05T10:00:00", { zone: state.timezone });
      const e = s.plus({ hours: 2 });
      addBlackout("Room-A", s.toISO(), e.toISO(), "Existing Event");
    };
    // expose for UI
        // -------- SUGGESTIONS HELPERS (add-on) --------
    // Align a DateTime to the next valid grid tick (e.g., 30 mins)
    const alignToStep = (dt, stepMins) => {
      const minutes = dt.minute + dt.hour*60;
      const next = Math.ceil(minutes / stepMins) * stepMins;
      return dt.set({ hour: Math.floor(next/60), minute: next%60, second: 0, millisecond: 0 });
    };

    // Find nearest alternatives around a requested window
    // opts: { stepMins: 30, radiusMins: 240, limit: 6, allowedStartMinutes: [0,30] }
    const suggestAlternatives = (roomIds, fromISO, toISO, opts = {}) => {
      const stepMins = opts.stepMins ?? (state.pricing.roundingStep || 15);
      const radiusMins = opts.radiusMins ?? 240; // +/- 4 hours
      const limit = opts.limit ?? 6;
      const allowedStartMinutes = opts.allowedStartMinutes ?? [0, 30]; // prefer :00 / :30

      const base = DateTime.fromISO(fromISO, { setZone: true });
      const endReq = DateTime.fromISO(toISO, { setZone: true });
      const durMins = endReq.diff(base, "minutes").minutes;

      const startSearch = base.minus({ minutes: radiusMins });
      const endSearch = base.plus({ minutes: radiusMins });

      const results = [];

      const trySlot = (roomId, startDT) => {
        if (!allowedStartMinutes.includes(startDT.minute)) return; // enforce :00 / :30 starts
        const endDT = startDT.plus({ minutes: durMins });
        const check = isAvailable(roomId, startDT.toISO(), endDT.toISO());
        if (check.available) {
          results.push({
            roomId,
            start: startDT.toISO(),
            end: endDT.toISO(),
            startEU: eu(startDT.toISO()),
            endEU: eu(endDT.toISO())
          });
        }
      };

      // Sweep forward then backward from the aligned request
      const alignedStart = alignToStep(base, stepMins);
      const step = { minutes: stepMins };

      for (let dt = alignedStart; dt <= endSearch && results.length < limit; dt = dt.plus(step)) {
        for (const roomId of roomIds) trySlot(roomId, dt);
      }
      for (let dt = alignedStart.minus(step); dt >= startSearch && results.length < limit; dt = dt.minus(step)) {
        for (const roomId of roomIds) trySlot(roomId, dt);
      }

      // Sort by nearest to requested start, then by roomId
      results.sort((a,b)=>{
        const da = Math.abs(DateTime.fromISO(a.start).diff(base, "minutes").minutes);
        const db = Math.abs(DateTime.fromISO(b.start).diff(base, "minutes").minutes);
        if (da !== db) return da - db;
        return a.roomId.localeCompare(b.roomId);
      });

      return results.slice(0, limit);
    };
    // -------- END SUGGESTIONS HELPERS --------

   window.mod = { state, eu, isAvailable, detectOOH, addBlackout, addTempBlackout, removeEvent, seedExamples, suggestAlternatives };

  })();
  </script>

  <!-- Render Admin UI -->
  <script>
    const { DateTime } = luxon;
    const mod = window.mod;

    const App = () => {
      const [roomId, setRoomId] = React.useState("Room-A");
      const [date, setDate] = React.useState(DateTime.now().setZone(mod.state.timezone).toISODate());
      const [start, setStart] = React.useState("10:00");
      const [end, setEnd] = React.useState("12:00");
      const [msg, setMsg] = React.useState("");
      const [preBuf, setPreBuf] = React.useState(mod.state.roomConfig[roomId]?.preBufferMins ?? 0);
      const [postBuf, setPostBuf] = React.useState(mod.state.roomConfig[roomId]?.postBufferMins ?? 0);
      const [tempAmt, setTempAmt] = React.useState(2);
      const [tempUnit, setTempUnit] = React.useState("hours");
      const [rounding, setRounding] = React.useState(mod.state.pricing.roundingStep || 15);
      const [tick, setTick] = React.useState(0);

      React.useEffect(()=>{ mod.seedExamples(); }, []);
      React.useEffect(()=>{
        setPreBuf(mod.state.roomConfig[roomId]?.preBufferMins ?? 0);
        setPostBuf(mod.state.roomConfig[roomId]?.postBufferMins ?? 0);
      }, [roomId]);

      const toISO = (d, hm) => {
        const [h,m] = hm.split(":").map(Number);
        return DateTime.fromISO(d, { zone: mod.state.timezone }).set({ hour:h, minute:m, second:0, millisecond:0 }).toISO();
      };

      const check = () => {
        const r = mod.isAvailable(roomId, toISO(date,start), toISO(date,end));
        setMsg(r.available ? "Available ✅" : "Unavailable ❌ — " + (r.reason || ""));
      };

      const addBlk = () => {
        const r = mod.addBlackout(roomId, toISO(date,start), toISO(date,end), "Admin Blackout");
        setMsg(r.ok ? "Blackout added." : "Error: " + r.reason);
        setTick(x=>x+1);
      };

      const addTemp = () => {
        const r = mod.addTempBlackout(roomId, toISO(date,start), Number(tempAmt||0), tempUnit, "Temp Block");
        setMsg(r.ok ? "Temp block added." : "Error: " + r.reason);
        setTick(x=>x+1);
      };

      const saveBuffers = () => {
        (mod.state.roomConfig[roomId] = mod.state.roomConfig[roomId] || {});
        mod.state.roomConfig[roomId].preBufferMins  = Number(preBuf||0);
        mod.state.roomConfig[roomId].postBufferMins = Number(postBuf||0);
        setMsg("Buffers saved for " + roomId);
      };

      const saveRounding = () => {
        mod.state.pricing.roundingStep = Number(rounding||15);
        setMsg("Rounding step set to " + mod.state.pricing.roundingStep + " minutes");
      };

      const events = (mod.state.calendars[roomId]||[]).slice().sort((a,b)=>a.startsAt.localeCompare(b.startsAt));

      return React.createElement('div', {}, [
        React.createElement('div', { className:'card', key:'controls' }, [
          React.createElement('h2', {}, ['Availability & Blackouts ', React.createElement('span',{className:'pill'},'Admin')]),
          React.createElement('div',{className:'row'},[
            'Room', React.createElement('select',{value:roomId,onChange:e=>setRoomId(e.target.value)},[
              React.createElement('option',{key:'A'},'Room-A'),
              React.createElement('option',{key:'B'},'Room-B')
            ]),
            'Date', React.createElement('input',{type:'date',value:date,onChange:e=>setDate(e.target.value)}),
            'From', React.createElement('input',{type:'time',value:start,onChange:e=>setStart(e.target.value), step: rounding*60}),
            'To', React.createElement('input',{type:'time',value:end,onChange:e=>setEnd(e.target.value), step: rounding*60}),
            React.createElement('button',{onClick:check},'Check Availability'),
            React.createElement('button',{onClick:addBlk},'Add Blackout')
          ]),
          React.createElement('div',{className:'row'},[
            React.createElement('strong',{},'Temp block:'),'Duration',
            React.createElement('input',{type:'number',min:1,style:{width:80},value:tempAmt,onChange:e=>setTempAmt(e.target.value)}),
            React.createElement('select',{value:tempUnit,onChange:e=>setTempUnit(e.target.value)},[
              React.createElement('option',{value:'hours'},'hours'),
              React.createElement('option',{value:'days'},'days'),
              React.createElement('option',{value:'weeks'},'weeks')
            ]),
            React.createElement('button',{onClick:addTemp},'Add Temp Block')
          ]),
          React.createElement('div',{className:'row'},[
            React.createElement('strong',{},'Default buffers for room:'),
            'Pre (mins)', React.createElement('input',{type:'number',min:0,style:{width:80},value:preBuf,onChange:e=>setPreBuf(e.target.value)}),
            'Post (mins)', React.createElement('input',{type:'number',min:0,style:{width:80},value:postBuf,onChange:e=>setPostBuf(e.target.value)}),
            React.createElement('button',{onClick:saveBuffers},'Save Buffers')
          ]),
          React.createElement('div',{className:'row'},[
            React.createElement('strong',{},'Rounding step (mins):'),
            React.createElement('select',{value:rounding, onChange:e=>setRounding(Number(e.target.value))},[
              React.createElement('option',{value:5},'5'),
              React.createElement('option',{value:10},'10'),
              React.createElement('option',{value:15},'15'),
              React.createElement('option',{value:30},'30'),
              React.createElement('option',{value:60},'60')
            ]),
            React.createElement('button',{onClick:saveRounding},'Save Rounding')
          ]),
          React.createElement('div',{className:'muted'},'“+01:00” is timezone (Irish Summer Time). Buffers and rounding are configurable above.'),
          React.createElement('div',{style:{marginTop:8}}, msg)
        ]),
        React.createElement('div', { className:'card', key:'events' }, [
          React.createElement('h3', {}, `Events for ${roomId}`),
          React.createElement('table',{}, [
            React.createElement('thead',{}, React.createElement('tr',{},[
              React.createElement('th',{},'Type'),
              React.createElement('th',{},'Title'),
              React.createElement('th',{},'Start (EU)'),
              React.createElement('th',{},'End (EU)'),
              React.createElement('th',{},'')
            ])),
            React.createElement('tbody',{}, (events.length? events.map(ev => React.createElement('tr',{key:ev.id},[
              React.createElement('td',{}, ev.type),
              React.createElement('td',{}, ev.title||''),
              React.createElement('td',{}, window.mod.eu(ev.startsAt)),
              React.createElement('td',{}, window.mod.eu(ev.endsAt)),
              React.createElement('td',{}, React.createElement('button',{onClick:()=>{ window.mod.removeEvent(roomId, ev.id); setTick(x=>x+1); }},'Delete'))
            ])) : React.createElement('tr',{}, React.createElement('td',{colSpan:5, className:'muted'},'No events yet.'))))
          ])
        ])
      ]);
    };

    ReactDOM.createRoot(document.getElementById('app')).render(React.createElement(App));
  </script>
</body>
</html>
