<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Admin â€” Availability & Blackouts</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/modern-normalize/modern-normalize.min.css">
  <style>
    body{font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Arial;padding:24px}
    .card{border:1px solid #e5e7eb;border-radius:16px;padding:16px;margin-bottom:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
    .row{display:flex;gap:8px;align-items:center;margin:8px 0;flex-wrap:wrap}
    input,select,button{padding:8px 10px;border-radius:10px;border:1px solid #d1d5db}
    table{width:100%;border-collapse:collapse}
    th,td{text-align:left;padding:8px;border-bottom:1px solid #eee}
    .muted{color:#6b7280;font-size:12px}
    .pill{background:#eef2ff;color:#3730a3;padding:2px 8px;border-radius:999px;font-size:12px}
  </style>
  <!-- React & Luxon from CDNs -->
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/luxon@3/build/global/luxon.min.js"></script>
</head>
<body>
  <div id="app"></div>

  <!-- Inline core (no imports) -->
  <script>
  (function(){
    const { DateTime, Interval } = luxon;
    const state = window.state = {
      timezone: "Europe/Dublin",
      calendars: { "Room-A": [], "Room-B": [] },
      roomConfig: { "Room-A": { preBufferMins: 15, postBufferMins: 15 }, "Room-B": { preBufferMins: 0, postBufferMins: 0 } },
      pricing: { earliestStart:"07:00", latestEnd:"22:00", roundingStep:15, halfDayHrs:4, dayHrs:8, oohPct:0.2 },
      openingHours: { MO:[{start:"07:00",end:"22:00"}], TU:[{start:"07:00",end:"22:00"}], WE:[{start:"07:00",end:"22:00"}], TH:[{start:"07:00",end:"22:00"}], FR:[{start:"07:00",end:"22:00"}], SA:[{start:"08:00",end:"20:00"}], SU:[] },
      defaults: { preBufferMins:0, postBufferMins:0, roundingStepMins:15, minLeadTimeMins:0, maxLeadTimeDays:365 }
    };
    const uid = () => Math.random().toString(36).slice(2,10);
    const parseISO = iso => DateTime.fromISO(iso, { setZone: true });
    const weekdayToken = dt => ["SU","MO","TU","WE","TH","FR","SA"][dt.weekday % 7];
    const isOnStep = (dt, step) => ((dt.minute + dt.hour*60) % step)===0 && dt.second===0 && dt.millisecond===0;
    const eu = iso => parseISO(iso).toFormat("HH:mm dd/MM/yyyy");
    const getRoomDefaults = roomId => state.roomConfig[roomId] || state.defaults;
    const applyBuffers = (ev, roomId) => {
      const cfg = getRoomDefaults(roomId);
      const pre = ev.preBufferMins ?? cfg.preBufferMins ?? 0;
      const post = ev.postBufferMins ?? cfg.postBufferMins ?? 0;
      return { start: parseISO(ev.startsAt).minus({minutes: pre}), end: parseISO(ev.endsAt).plus({minutes: post}) };
    };
    const intervalsOverlap = (aStart,aEnd,bStart,bEnd) => aStart < bEnd && bStart < aEnd;
    const checkOverlap = (roomId, candidate) => {
      const cal = state.calendars[roomId] || [];
      const { start: cStart, end: cEnd } = applyBuffers(candidate, roomId);
      for (const ev of cal) {
        if (ev.status === "cancelled") continue;
        const { start, end } = applyBuffers(ev, roomId);
        if (intervalsOverlap(cStart, cEnd, start, end)) {
          return { ok:false, reason:`Conflicts with ${ev.type} (${ev.title||ev.id})`, conflictingEvent: ev };
        }
      }
      return { ok:true };
    };
    const detectOOH = (ev) => {
      const start = parseISO(ev.startsAt), end = parseISO(ev.endsAt);
      let cursor = start;
      while (cursor < end){
        const segEnd = DateTime.min(cursor.endOf("day"), end);
        const ranges = state.openingHours[weekdayToken(cursor)] || [];
        const openIntervals = ranges.map(r => {
          const [sh, sm] = r.start.split(":").map(Number);
          const [eh, em] = r.end.split(":").map(Number);
          return Interval.fromDateTimes(
            cursor.set({hour:sh, minute:sm, second:0, millisecond:0}),
            cursor.set({hour:eh, minute:em, second:0, millisecond:0})
          );
        });
        const seg = Interval.fromDateTimes(cursor, segEnd);
        const covered = openIntervals.some(iv => iv.overlaps(seg) || iv.engulfs(seg));
        if (!covered) return true;
        cursor = segEnd;
      }
      return false;
    };
    const isAvailable = (roomId, fromISO, toISO) => {
      const step = state.pricing.roundingStep ?? state.defaults.roundingStepMins;
      const s = parseISO(fromISO), e = parseISO(toISO);
      if (!isOnStep(s, step) || !isOnStep(e, step)) return { available:false, reason:`Times must align to ${step}-minute steps` };
      const probe = { id:"_probe_", roomId, type:"BOOKING", status:"provisional", startsAt:fromISO, endsAt:toISO, createdBy:"system", createdAt: DateTime.now().toISO() };
      const overlap = checkOverlap(roomId, probe);
      if (!overlap.ok) return { available:false, reason: overlap.reason, conflictingEvent: overlap.conflictingEvent };
      return { available:true };
    };
    const addBlackout = (roomId, startsAtISO, endsAtISO, title="Blackout") => {
      const ev = { id:uid(), roomId, type:"BLACKOUT", status:"confirmed", startsAt:startsAtISO, endsAt:endsAtISO, title, createdBy:"admin", createdAt: DateTime.now().toISO() };
      const overlap = checkOverlap(roomId, ev);
      if (!overlap.ok) return { ok:false, reason: overlap.reason, conflictingEvent: overlap.conflictingEvent };
      (state.calendars[roomId] = state.calendars[roomId] || []).push(ev);
      return { ok:true, event: ev };
    };
    const addTempBlackout = (roomId, startsAtISO, amount, unit, title="Temp Block") => {
      const dur = {};
      if (unit === "hours") dur.hours = amount;
      else if (unit === "days") dur.days = amount;
      else if (unit === "weeks") dur.weeks = amount;
      else return { ok:false, reason:"Invalid unit (hours|days|weeks)" };
      const endsAtISO = parseISO(startsAtISO).plus(dur).toISO();
      const ev = { id:uid(), roomId, type:"TEMP_BLACKOUT", status:"confirmed", startsAt:startsAtISO, endsAt:endsAtISO, title, createdBy:"admin", createdAt: DateTime.now().toISO() };
      const overlap = checkOverlap(roomId, ev);
      if (!overlap.ok) return { ok:false, reason: overlap.reason, conflictingEvent: overlap.conflictingEvent };
      (state.calendars[roomId] = state.calendars[roomId] || []).push(ev);
      return { ok:true, event: ev };
    };
    const removeEvent = (roomId, id) => {
      const arr = state.calendars[roomId] || [];
      const idx = arr.findIndex(e => e.id === id);
      if (idx === -1) return { ok:false, reason:"Not found" };
      arr.splice(idx,1);
      return { ok:true };
    };
    const seedExamples = () => {
      const s = DateTime.fromISO("2025-11-05T10:00:00", { zone: state.timezone });
      const e = s.plus({ hours: 2 });
      addBlackout("Room-A", s.toISO(), e.toISO(), "Existing Event");
    };

    // Expose small API for serverless functions if needed
    window.mod = { state, eu, isAvailable, detectOOH, addBlackout, addTempBlackout, removeEvent, seedExamples };
  })();
  </script>

  <!-- Render Admin UI -->
  <script>
    const { DateTime } = luxon;
    const mod = window.mod;

    const App = () => {
      const [roomId, setRoomId] = React.useState("Room-A");
      const [date, setDate] = React.useState(DateTime.now().setZone(mod.state.timezone).toISODate());
      const [start, setStart] = React.useState("10:00");
      const [end, setEnd] = React.useState("12:00");
      const [msg, setMsg] = React.useState("");
      const [preBuf, setPreBuf] = React.useState(mod.state.roomConfig[roomId]?.preBufferMins ?? 0);
      const [postBuf, setPostBuf] = R
