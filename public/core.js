
// Works in browser (window.luxon) AND in Node (require)
const LUX = (typeof luxon !== 'undefined') ? luxon : require('luxon');
const { DateTime, Duration, Interval } = LUX;

export const state = { timezone: "Europe/Dublin", calendars: { "Room-A": [], "Room-B": [] }, pricing: { earliestStart: "07:00", latestEnd: "22:00", roundingStep: 15, halfDayHrs: 4, dayHrs: 8, oohPct: 0.2 }, openingHours: { MO:[{start:"07:00",end:"22:00"}], TU:[{start:"07:00",end:"22:00"}], WE:[{start:"07:00",end:"22:00"}], TH:[{start:"07:00",end:"22:00"}], FR:[{start:"07:00",end:"22:00"}], SA:[{start:"08:00",end:"20:00"}], SU:[] }, defaults:{ preBufferMins:0, postBufferMins:0, roundingStepMins:15, minLeadTimeMins:0, maxLeadTimeDays:365 } };
export function uid(){ return Math.random().toString(36).slice(2,10); }
function parseISO(iso){ return DateTime.fromISO(iso,{setZone:true}); }
function weekdayToken(dt){ const WD=["SU","MO","TU","WE","TH","FR","SA"]; return WD[dt.weekday%7]; }
export function applyBuffers(ev,cal){ const pre=ev.preBufferMins??state.defaults.preBufferMins; const post=ev.postBufferMins??state.defaults.postBufferMins; return { start:parseISO(ev.startsAt).minus({minutes:pre}), end:parseISO(ev.endsAt).plus({minutes:post}) }; }
export function intervalsOverlap(aStart,aEnd,bStart,bEnd){ return aStart < bEnd && bStart < aEnd; }
export function checkOverlap(roomId,candidate){ const cal=state.calendars[roomId]||[]; const {start:cStart,end:cEnd}=applyBuffers(candidate); for(const ev of cal){ if(ev.status==='cancelled') continue; const {start,end}=applyBuffers(ev); if(intervalsOverlap(cStart,cEnd,start,end)) return { ok:false, reason:`Conflicts with ${ev.type} (${ev.title||ev.id})`, conflictingEvent:ev }; } return { ok:true }; }
export function isOnStep(dt,stepMins){ return (dt.minute+dt.hour*60)%stepMins===0 && dt.second===0 && dt.millisecond===0; }
export function detectOOH(ev){ const start=parseISO(ev.startsAt), end=parseISO(ev.endsAt); let cursor=start; while(cursor<end){ const segEnd=DateTime.min(cursor.endOf('day'),end); const weekday=weekdayToken(cursor); const ranges=state.openingHours[weekday]||[]; const openIntervals=ranges.map(r=>{ const [sh,sm]=r.start.split(':').map(Number); const [eh,em]=r.end.split(':').map(Number); return Interval.fromDateTimes(cursor.set({hour:sh,minute:sm,second:0,millisecond:0}), cursor.set({hour:eh,minute:em,second:0,millisecond:0})); }); const seg=Interval.fromDateTimes(cursor,segEnd); const covered=openIntervals.some(iv=>iv.overlaps(seg)||iv.engulfs(seg)); if(!covered) return true; cursor=segEnd; } return false; }
export function isAvailable(roomId,fromISO,toISO){ const step=state.pricing.roundingStep??state.defaults.roundingStepMins; const s=parseISO(fromISO), e=parseISO(toISO); if(!isOnStep(s,step)||!isOnStep(e,step)) return { available:false, reason:`Times must align to ${step}-minute steps` }; const probe={ id:'_probe_', roomId, type:'BOOKING', status:'provisional', startsAt:fromISO, endsAt:toISO, createdBy:'system', createdAt:DateTime.now().toISO() }; const overlap=checkOverlap(roomId,probe); if(!overlap.ok) return { available:false, reason:overlap.reason, conflictingEvent:overlap.conflictingEvent }; return { available:true }; }
export function addBlackout(roomId,startsAtISO,endsAtISO,title='Blackout'){ const ev={ id:uid(), roomId, type:'BLACKOUT', status:'confirmed', startsAt:startsAtISO, endsAt:endsAtISO, title, createdBy:'admin', createdAt:DateTime.now().toISO() }; const overlap=checkOverlap(roomId,ev); if(!overlap.ok) return { ok:false, reason:overlap.reason, conflictingEvent:overlap.conflictingEvent }; state.calendars[roomId]=state.calendars[roomId]||[]; state.calendars[roomId].push(ev); return { ok:true, event:ev }; }
export function removeEvent(roomId,id){ const arr=state.calendars[roomId]||[]; const idx=arr.findIndex(e=>e.id===id); if(idx===-1) return { ok:false, reason:'Not found' }; arr.splice(idx,1); return { ok:true }; }
export function seedExamples(){ const s=DateTime.fromISO('2025-11-05T10:00:00',{zone:state.timezone}); const e=s.plus({hours:2}); addBlackout('Room-A',s.toISO(), e.toISO(), 'Existing Event'); }
